<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>API + System Design + RAG + Transformer Interview Notes</title>
    <meta
      name="description"
      content="High-detail, glance-friendly technical interview notes focused on API design, system design, RAG code flow, and transformer architecture."
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600;9..144,700&family=Space+Grotesk:wght@400;500;700&family=JetBrains+Mono:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="bg-grid" aria-hidden="true"></div>
    <div class="orb orb-a" aria-hidden="true"></div>
    <div class="orb orb-b" aria-hidden="true"></div>
    <div class="orb orb-c" aria-hidden="true"></div>

    <header class="hero" id="top">
      <div class="hero-copy">
        <p class="eyebrow">Technical Interview Review</p>
        <h1>API Design + System Design + RAG + Transformer Notes</h1>
        <p class="hero-lead">
          A dense, glance-first study page focused only on the topics you asked for: API design
          principles, system design principles (FR/NFR), your RAG/agentic retrieval-verification
          flow, and transformer architecture notes.
        </p>
        <div class="chip-row" role="list" aria-label="Topic chips">
          <span class="chip" role="listitem">API Design Principles</span>
          <span class="chip" role="listitem">FR vs NFR</span>
          <span class="chip" role="listitem">RAG Verification Loop</span>
          <span class="chip" role="listitem">Retriever vs Verifier</span>
          <span class="chip" role="listitem">Retrieval Metrics</span>
          <span class="chip" role="listitem">Transformer Architecture</span>
        </div>
      </div>

      <div class="hero-stack">
        <section class="hero-card searchable" data-search="technical intro api design system design rag transformer intro answer">
          <div class="card-kicker">30s Technical Intro</div>
          <p>
            I focus on building reliable APIs and automation systems, with strong attention to
            contracts, retries, idempotency, and observability. I also work on LLM systems, so I can
            explain both RAG pipeline design and verification tradeoffs, plus transformer
            fundamentals from an implementation perspective.
          </p>
          <button class="ghost copy-btn" type="button" data-copy-target="intro-text">Copy Intro</button>
          <textarea id="intro-text" class="visually-hidden" readonly>
I focus on building reliable APIs and automation systems, with strong attention to contracts, retries, idempotency, and observability. I also work on LLM systems, so I can explain both RAG pipeline design and verification tradeoffs, plus transformer fundamentals from an implementation perspective.
          </textarea>
        </section>

        <section class="hero-card compact searchable" data-search="how to use notes review order dense mode search expand collapse">
          <div class="card-kicker">How To Use This Page</div>
          <ul class="tight-list">
            <li>Use search for keywords: `idempotency`, `RAG`, `MRR`, `QKV`, `FR/NFR`</li>
            <li>Use `Expand All` for deep review</li>
            <li>Use `Dense Mode` for last-minute revision</li>
            <li>Read sections in sidebar order for a full technical pass</li>
          </ul>
        </section>
      </div>
    </header>

    <div class="toolbar" aria-label="Page controls">
      <div class="search-wrap">
        <label for="search" class="visually-hidden">Search notes</label>
        <input id="search" type="search" placeholder="Search notes: idempotency, contract, verifier, MRR, attention..." />
      </div>
      <div class="toolbar-actions">
        <button id="expandAll" type="button">Expand All</button>
        <button id="collapseAll" type="button">Collapse All</button>
        <button id="toggleDense" type="button">Dense Mode</button>
      </div>
      <p id="searchStatus" class="search-status" aria-live="polite">Showing all notes</p>
    </div>

    <div class="layout">
      <aside class="sidebar" aria-label="Section navigation">
        <nav class="side-nav">
          <a href="#rapid">Rapid Review</a>
          <a href="#api">API Design Principles</a>
          <a href="#system">System Design Principles</a>
          <a href="#rag-basics">RAG Concepts</a>
          <a href="#rag-code">RAG Code Alignment</a>
          <a href="#transformer">Transformer Notes</a>
          <a href="#practice">Practice Questions</a>
          <a href="#final-check">Final Cram Sheet</a>
        </nav>

        <section class="sidebar-card searchable" data-search="review order interview prep technical topics only">
          <h2>Review Order</h2>
          <ol class="tight-list ordered">
            <li>`Rapid Review`</li>
            <li>`API Design Principles`</li>
            <li>`System Design Principles`</li>
            <li>`RAG Concepts + Code Alignment`</li>
            <li>`Transformer Notes`</li>
            <li>`Practice + Final Cram Sheet`</li>
          </ol>
        </section>

        <section class="sidebar-card searchable" data-search="interview answer structure technical problem design tradeoff result">
          <h2>Best Answer Shape</h2>
          <p>
            For technical answers: <strong>Problem -> Design choice -> Tradeoff -> Failure handling
            -> Result</strong>.
          </p>
          <p class="muted small">
            This works for API design, system design, and RAG pipeline explanations.
          </p>
        </section>
      </aside>

      <main class="content">
        <section id="rapid" class="panel">
          <div class="section-head">
            <p class="eyebrow">Section 1</p>
            <h2>Rapid Review Board (Glance First)</h2>
            <p>High-signal points you should be able to say confidently.</p>
          </div>

          <div class="cards two-col">
            <article class="note-card searchable" data-search="api design core principles contract idempotency retries errors versioning">
              <h3>API Design: Core Principles</h3>
              <ul>
                <li>Clear contract (schema, status codes, examples, error shape).</li>
                <li>Idempotency for retry safety on side-effecting writes.</li>
                <li>Structured errors with request IDs and actionable messages.</li>
                <li>Retry logic only for transient failures, with backoff + jitter.</li>
                <li>Versioning + deprecation strategy from day 1.</li>
                <li>Observability: logs, metrics, tracing, health checks.</li>
              </ul>
            </article>

            <article class="note-card searchable" data-search="system design fr nfr clarifying questions capacity tradeoffs">
              <h3>System Design: What To Do First</h3>
              <ol>
                <li>Clarify FRs (what users can do).</li>
                <li>Clarify NFRs (scale, latency, availability, security, consistency).</li>
                <li>Estimate capacity (RPS, storage, hot reads/writes).</li>
                <li>Propose architecture driven by NFRs.</li>
                <li>Discuss failure modes and tradeoffs.</li>
              </ol>
            </article>

            <article class="note-card searchable" data-search="rag loop retrieve augment generate verify retry bounded loop">
              <h3>RAG Loop: Simple Explanation</h3>
              <ul>
                <li>Retrieve relevant chunks from vector DB.</li>
                <li>Generate answer using retrieved context only.</li>
                <li>Verify answer is supported by context.</li>
                <li>If fail, rewrite query and retrieve again (max 2-3 tries).</li>
                <li>If still fail, abstain / insufficient evidence.</li>
              </ul>
            </article>

            <article class="note-card searchable" data-search="transformer few lines self attention multi head residual layer norm ffn">
              <h3>Transformer: Few-Line Answer</h3>
              <p>
                Transformers use self-attention so each token can weigh other tokens in parallel,
                then refine representations through repeated blocks of attention + feed-forward
                layers, with residual connections and normalization for stable deep training.
              </p>
            </article>
          </div>

          <div class="banner searchable" data-search="core narrative technical interview focus">
            <p>
              <strong>Core technical narrative:</strong> You think in terms of contracts, failure
              handling, bounded retries, observability, and verifiable outputs.
            </p>
          </div>
        </section>

        <section id="api" class="panel">
          <div class="section-head">
            <p class="eyebrow">Section 2</p>
            <h2>API Design Principles (Detailed Interview Notes)</h2>
            <p>
              Focus areas you explicitly asked for: contract, workflow, idempotency,
              authentication, retry logic, error handling, versioning, plus related design principles.
            </p>
          </div>

          <div class="banner searchable" data-search="api design summary one line">
            <p>
              <strong>Interview one-liner:</strong> "I design APIs as reliable contracts with clear
              schemas, safe retries, explicit error semantics, and operational visibility."
            </p>
          </div>

          <div class="cards two-col">
            <details class="deep-card searchable" open data-search="contract openapi pydantic json schema request response validation examples">
              <summary>1. Contract (The Foundation)</summary>
              <div class="deep-content">
                <p><strong>Definition:</strong> The agreement between API provider and consumer.</p>
                <ul>
                  <li>Endpoints + HTTP methods</li>
                  <li>Request schema (headers, query params, body)</li>
                  <li>Response schema (success + error)</li>
                  <li>Status codes and semantics</li>
                  <li>Validation rules, enums, limits</li>
                  <li>Authentication requirements</li>
                  <li>Rate limits / usage expectations</li>
                </ul>
                <p><strong>Best practice:</strong> contract-first with OpenAPI + JSON schema/Pydantic.</p>
                <p><strong>Why interviewers care:</strong> contracts reduce ambiguity, integration bugs, and support load.</p>
              </div>
            </details>

            <details class="deep-card searchable" data-search="workflow design synchronous asynchronous 202 accepted polling webhooks status url">
              <summary>2. Workflow Design (Sync vs Async)</summary>
              <div class="deep-content">
                <p><strong>Rule:</strong> If an operation can take more than a few seconds, make it asynchronous.</p>
                <ul>
                  <li><strong>Synchronous:</strong> reads, metadata lookups, small updates</li>
                  <li><strong>Asynchronous:</strong> long-running processing, orchestrations, large imports</li>
                  <li>Return <code>202 Accepted</code> + operation/job ID + status endpoint</li>
                  <li>Support polling first; add webhooks/streaming when required</li>
                </ul>
                <p><strong>Interview phrase:</strong> "I separate submission from execution for long-running work."</p>
              </div>
            </details>

            <details class="deep-card searchable" data-search="idempotency idempotency key duplicate prevention retry safe post put delete patch">
              <summary>3. Idempotency (Reliability Under Network Failure)</summary>
              <div class="deep-content">
                <p>
                  <strong>Problem:</strong> client times out after server processes request, client retries,
                  duplicate side effect occurs.
                </p>
                <ul>
                  <li>GET/PUT/DELETE are typically idempotent when designed correctly.</li>
                  <li>POST is not idempotent by default.</li>
                  <li>Use <code>Idempotency-Key</code> for side-effecting POSTs.</li>
                  <li>Persist request fingerprint + result for a bounded time window.</li>
                  <li>Use DB unique constraints as a second safeguard.</li>
                </ul>
                <p><strong>Interview phrase:</strong> "Idempotency is what makes retries safe."</p>
              </div>
            </details>

            <details class="deep-card searchable" data-search="authentication authorization api keys oauth jwt mtls scopes roles">
              <summary>4. Authentication + Authorization</summary>
              <div class="deep-content">
                <p><strong>Authentication:</strong> who is calling the API.</p>
                <p><strong>Authorization:</strong> what they are allowed to do.</p>
                <ul>
                  <li><strong>API Keys:</strong> simple service access, rotateable, hash at rest</li>
                  <li><strong>OAuth/JWT:</strong> user delegation + scopes + expiry</li>
                  <li><strong>mTLS:</strong> strong service-to-service trust where needed</li>
                  <li>Enforce authorization on every request (resource ownership, roles, scopes)</li>
                  <li>Combine with quotas/rate limits for abuse prevention</li>
                </ul>
                <p><strong>Common mistake:</strong> stopping at authn and forgetting authz checks.</p>
              </div>
            </details>

            <details class="deep-card searchable" data-search="retry logic resilience transient errors exponential backoff jitter retry-after tenacity">
              <summary>5. Retry Logic + Resilience</summary>
              <div class="deep-content">
                <p><strong>Retry transient errors only:</strong> network issues, <code>408</code>, <code>429</code>, <code>502/503/504</code>.</p>
                <ul>
                  <li>Exponential backoff with jitter</li>
                  <li>Respect <code>Retry-After</code></li>
                  <li>Cap attempts (usually 3-5)</li>
                  <li>Bound total timeout budget</li>
                  <li>Log retry attempts and reasons</li>
                </ul>
                <p><strong>Do not retry:</strong> most 4xx errors, unless explicitly retryable.</p>
              </div>
            </details>

            <details class="deep-card searchable" data-search="error handling structured error payload request id status codes validation details rfc7807">
              <summary>6. Error Handling (Structured + Actionable)</summary>
              <div class="deep-content">
                <p>Errors should tell the client <strong>what failed</strong> and <strong>what to do next</strong>.</p>
                <ul>
                  <li>Consistent error schema (`error_code`, `message`, `details`, `request_id`, `timestamp`)</li>
                  <li>Use correct HTTP status code semantics</li>
                  <li>Field-level validation details for request errors</li>
                  <li>Do not leak internal stack traces in responses</li>
                  <li>Log full diagnostic info server-side with request IDs</li>
                </ul>
                <div class="code-block">
                  <pre><code>{
  "error_code": "validation_error",
  "message": "Request validation failed",
  "details": [{"field": "partition", "message": "Invalid value"}],
  "request_id": "req_abc123",
  "timestamp": "2026-02-22T12:00:00Z"
}</code></pre>
                </div>
              </div>
            </details>

            <details class="deep-card searchable" data-search="versioning deprecation path versioning v1 v2 sunset headers backward compatibility">
              <summary>7. Versioning + Deprecation Strategy</summary>
              <div class="deep-content">
                <ul>
                  <li>Version from day 1 (`/v1/...` is simple and explicit)</li>
                  <li>Prefer additive changes over breaking changes</li>
                  <li>For breaking changes, release new version and keep overlap period</li>
                  <li>Provide migration docs/examples and sunset timeline</li>
                  <li>Monitor usage before retirement</li>
                </ul>
                <p><strong>Interview phrase:</strong> "Versioning is change management, not just URL structure."</p>
              </div>
            </details>

            <details class="deep-card searchable" data-search="rate limiting throttling token bucket sliding window redis retry-after quota">
              <summary>8. Rate Limiting + Throttling</summary>
              <div class="deep-content">
                <ul>
                  <li>Token bucket for burst + steady-state control</li>
                  <li>Sliding window (often Redis-backed) for distributed servers</li>
                  <li>Return <code>429</code> + `Retry-After` + limit headers</li>
                  <li>Different limits by client tier/use-case</li>
                  <li>Separate request-rate limits from business/resource quotas</li>
                </ul>
              </div>
            </details>

            <details class="deep-card searchable" data-search="pagination filtering offset cursor sorting response metadata">
              <summary>9. Pagination + Filtering + Sorting</summary>
              <div class="deep-content">
                <ul>
                  <li>Offset pagination is simple; cursor pagination is better for large/changing datasets</li>
                  <li>Document defaults and sort order explicitly</li>
                  <li>Return pagination metadata (`has_more`, `next_cursor`, `limit`)</li>
                  <li>Validate filter params to avoid silent weird behavior</li>
                </ul>
              </div>
            </details>

            <details class="deep-card searchable" data-search="observability monitoring tracing metrics logs health checks supportability">
              <summary>10. Observability + Operability</summary>
              <div class="deep-content">
                <ul>
                  <li>Structured logs with request IDs and endpoint labels</li>
                  <li>Metrics: request count, latency p95/p99, error rates, retries</li>
                  <li>Tracing across API -> queue -> worker -> downstream service</li>
                  <li>Health/readiness endpoints</li>
                  <li>Audit logs for sensitive writes/admin actions</li>
                </ul>
                <p><strong>Why it matters:</strong> an API is only as good as your ability to operate and debug it.</p>
              </div>
            </details>

            <details class="deep-card searchable" data-search="testing api design unit integration contract tests end to end">
              <summary>11. Testing Strategy (Often Missed in Interview Answers)</summary>
              <div class="deep-content">
                <ul>
                  <li>Unit tests for validation and business logic</li>
                  <li>Integration tests for DB/external service interactions</li>
                  <li>Contract tests to prevent schema drift</li>
                  <li>Idempotency and retry behavior tests</li>
                  <li>Error-path tests (timeouts, upstream 5xx, malformed input)</li>
                </ul>
              </div>
            </details>
          </div>

          <div class="table-wrap searchable" data-search="http status code cheat sheet api interview 200 201 202 400 401 403 404 409 422 429 503">
            <table>
              <caption>HTTP Status Code Cheat Sheet (Interview-Ready)</caption>
              <thead>
                <tr>
                  <th>Code</th>
                  <th>Meaning</th>
                  <th>Typical Use</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>200</td><td>OK</td><td>Successful read/update returning data</td></tr>
                <tr><td>201</td><td>Created</td><td>Resource created synchronously</td></tr>
                <tr><td>202</td><td>Accepted</td><td>Async work accepted (not completed yet)</td></tr>
                <tr><td>204</td><td>No Content</td><td>Successful delete or no-body action</td></tr>
                <tr><td>400</td><td>Bad Request</td><td>Malformed request / basic validation failure</td></tr>
                <tr><td>401</td><td>Unauthorized</td><td>Missing/invalid credentials</td></tr>
                <tr><td>403</td><td>Forbidden</td><td>Authenticated but not allowed</td></tr>
                <tr><td>404</td><td>Not Found</td><td>Unknown resource</td></tr>
                <tr><td>409</td><td>Conflict</td><td>Invalid state transition / duplicate conflict</td></tr>
                <tr><td>422</td><td>Unprocessable Entity</td><td>Semantic validation failure</td></tr>
                <tr><td>429</td><td>Too Many Requests</td><td>Rate limit exceeded</td></tr>
                <tr><td>500</td><td>Internal Server Error</td><td>Unexpected server failure</td></tr>
                <tr><td>503</td><td>Service Unavailable</td><td>Temporary downstream/system outage</td></tr>
              </tbody>
            </table>
          </div>
        </section>

        <section id="system" class="panel">
          <div class="section-head">
            <p class="eyebrow">Section 3</p>
            <h2>System Design Principles (FR / NFR + Interview Flow)</h2>
            <p>How to structure system design answers so they are rigorous and easy to follow.</p>
          </div>

          <div class="cards two-col">
            <article class="note-card searchable" data-search="functional requirements what system does examples">
              <h3>Functional Requirements (FR) = What The System Does</h3>
              <ul>
                <li>User-visible features and capabilities</li>
                <li>Examples: submit job, check status, cancel, list resources, get logs</li>
                <li>Usually phrased as: "Users can..." / "System must support..." (feature)</li>
              </ul>
            </article>

            <article class="note-card searchable" data-search="non functional requirements how well performance availability scalability security">
              <h3>Non-Functional Requirements (NFR) = How Well It Does It</h3>
              <ul>
                <li>Quality attributes and constraints</li>
                <li>Examples: latency, throughput, uptime, security, consistency, cost</li>
                <li>Usually phrased as: "must handle X", "p95 < Y", "99.9% uptime"</li>
              </ul>
            </article>
          </div>

          <details class="deep-card searchable" open data-search="pass cures acronym performance availability scalability security consistency usability reliability extensibility supportability">
            <summary>PASS CURES (NFR Checklist Acronym)</summary>
            <div class="deep-content">
              <div class="chip-row">
                <span class="chip chip-outline">Performance</span>
                <span class="chip chip-outline">Availability</span>
                <span class="chip chip-outline">Scalability</span>
                <span class="chip chip-outline">Security</span>
                <span class="chip chip-outline">Consistency</span>
                <span class="chip chip-outline">Usability</span>
                <span class="chip chip-outline">Reliability</span>
                <span class="chip chip-outline">Extensibility</span>
                <span class="chip chip-outline">Supportability</span>
              </div>
              <p class="muted">Use this checklist after you list FRs so you do not miss critical constraints.</p>
            </div>
          </details>

          <details class="deep-card searchable" data-search="system design interview flow clarify requirements capacity estimate architecture deep dive tradeoffs">
            <summary>Recommended System Design Interview Flow</summary>
            <div class="deep-content">
              <ol>
                <li>Clarify problem statement and scope</li>
                <li>List functional requirements</li>
                <li>List non-functional requirements (with assumptions if not given)</li>
                <li>Estimate capacity (RPS, storage, bandwidth, hot paths)</li>
                <li>Propose high-level architecture</li>
                <li>Deep dive into one or two critical components</li>
                <li>Discuss tradeoffs, bottlenecks, and failure handling</li>
              </ol>
            </div>
          </details>

          <details class="deep-card searchable" data-search="clarifying questions system design api service interview">
            <summary>High-Value Clarifying Questions</summary>
            <div class="deep-content">
              <ul>
                <li>What operations are in scope and out of scope?</li>
                <li>How many users / requests / jobs per day? Peak load?</li>
                <li>Latency targets for reads vs writes?</li>
                <li>Availability expectations and downtime tolerance?</li>
                <li>Consistency requirements (strong vs eventual) for critical data?</li>
                <li>Security/compliance constraints?</li>
                <li>Retention period and audit requirements?</li>
              </ul>
            </div>
          </details>

          <details class="deep-card searchable" data-search="capacity estimation template rps storage database qps example">
            <summary>Capacity Estimation Template (Reusable)</summary>
            <div class="deep-content">
              <p><strong>Template assumptions (example):</strong></p>
              <ul>
                <li>Active users = 10,000</li>
                <li>Writes/day = 100,000</li>
                <li>Peak write load = 1,000/minute = ~17 RPS</li>
                <li>Read:write ratio = 10:1 => ~170 read RPS</li>
                <li>Total peak API load ~200 RPS</li>
              </ul>
              <p><strong>Storage estimation:</strong></p>
              <ul>
                <li>Entities/day x retention_days x avg_entity_size</li>
                <li>Add overhead for indexes, replicas, logs, backups</li>
              </ul>
              <p class="muted">Interviewers care more about reasonable assumptions and method than exact numbers.</p>
            </div>
          </details>

          <details class="deep-card searchable" data-search="system architecture principles stateless api queue workers db cache reliability">
            <summary>Architecture Principles You Should Mention</summary>
            <div class="deep-content">
              <ul>
                <li>Stateless API servers behind a load balancer</li>
                <li>Persist intent before external side effects</li>
                <li>Async queue/workflow engine for long-running operations</li>
                <li>Retries with backoff at worker layer, not blind client loops only</li>
                <li>Cache hot reads carefully; preserve consistency for critical writes</li>
                <li>Observability end-to-end (logs + metrics + tracing)</li>
              </ul>
            </div>
          </details>

          <details class="deep-card searchable" data-search="tradeoffs performance consistency availability cost security usability system design">
            <summary>Tradeoffs to Discuss Explicitly</summary>
            <div class="deep-content">
              <ul>
                <li><strong>Performance vs consistency:</strong> faster cached/read-replica reads may be slightly stale</li>
                <li><strong>Availability vs cost:</strong> stronger redundancy increases operational complexity/cost</li>
                <li><strong>Security vs usability:</strong> stronger auth mechanisms can increase onboarding friction</li>
                <li><strong>Simplicity vs feature richness:</strong> polling is simpler than webhooks/streams and often enough initially</li>
              </ul>
            </div>
          </details>

          <div class="banner searchable" data-search="interview opener system design clarify functional non functional requirements">
            <p>
              <strong>System design opener:</strong> "Before drawing architecture, I want to clarify
              the functional requirements and the key non-functional constraints because scale,
              latency, availability, and consistency will drive the design choices."
            </p>
          </div>
        </section>

        <section id="rag-basics" class="panel">
          <div class="section-head">
            <p class="eyebrow">Section 4</p>
            <h2>RAG Concepts (Your Doubts Clarified)</h2>
            <p>Clear answers to your questions about retrieval, verification, looping, and chunking.</p>
          </div>

          <div class="cards two-col">
            <article class="note-card searchable" data-search="embedding vs vectorization difference embed vector vector db">
              <h3>Embedding vs Vectorization (Clear Terms)</h3>
              <ul>
                <li><strong>Embedding</strong> = the process/model that maps text to numbers</li>
                <li><strong>Vector</strong> = the numeric result (e.g., list of floats)</li>
                <li><strong>Vectorization</strong> = commonly used synonym for the embedding process</li>
                <li><strong>Vector DB</strong> = stores vectors + metadata for similarity search</li>
              </ul>
              <div class="diagram mono">Text -> Embedding Model -> Vector -> Vector Database</div>
            </article>

            <article class="note-card searchable" data-search="how does retrieved answer check right answer verification why">
              <h3>Doubt 1: How/Why Verify the Answer?</h3>
              <ul>
                <li>Retriever returns candidate evidence, not guaranteed truth</li>
                <li>LLM can hallucinate even with good context</li>
                <li>Verifier checks if generated answer is supported by retrieved chunks</li>
                <li>This is usually <strong>faithfulness/groundedness</strong>, not global truth checking</li>
              </ul>
            </article>

            <article class="note-card searchable" data-search="why go back to vector db retrieval retry query rewrite">
              <h3>Doubt 2: Why Go Back To Vector DB?</h3>
              <ul>
                <li>Initial retrieval may miss the right chunk due to question phrasing</li>
                <li>Query rewrite changes embedding and retrieved candidates</li>
                <li>Retrying retrieval improves evidence before regenerating</li>
                <li>Otherwise, generation may repeat the same unsupported answer</li>
              </ul>
            </article>

            <article class="note-card searchable" data-search="how many retry iterations max loops rag process">
              <h3>Doubt 3: How Many Times To Loop?</h3>
              <ul>
                <li>Use a bounded loop: usually <strong>2-3 iterations</strong></li>
                <li>Stop on PASS / high confidence / sufficient support</li>
                <li>More retries increase latency and cost with diminishing returns</li>
                <li>Final fallback should be abstain / insufficient evidence</li>
              </ul>
            </article>

            <article class="note-card searchable" data-search="chunk by words simple chunking for learning explaining to others">
              <h3>Doubt 4: Can We Chunk By Words for Simplicity?</h3>
              <ul>
                <li><strong>Yes</strong>, especially for learning and explaining the pipeline</li>
                <li>Word-based chunks are simple and deterministic</li>
                <li>Tradeoff: chunks can split sentences and reduce semantic quality</li>
                <li>Sentence/semantic chunking is usually better for production retrieval quality</li>
              </ul>
            </article>
          </div>

          <details class="deep-card searchable" open data-search="retriever verifier agent or tool llm judge hybrid verifier">
            <summary>Retriever vs Verifier: Agent, Tool, or Both?</summary>
            <div class="deep-content">
              <p><strong>Short answer:</strong> both are valid; choose the simplest reliable option.</p>
              <ul>
                <li><strong>Retriever</strong> is typically a tool-backed component:
                  embed query -> search vector DB -> rank top-K chunks.
                </li>
                <li><strong>Verifier</strong> can be:
                  tool-based (string/span/quote checks),
                  LLM-as-judge (semantic support check),
                  or hybrid (tool first, LLM only if needed).
                </li>
                <li>"Agent" usually refers to orchestration/decision logic, not necessarily the verification primitive itself.</li>
              </ul>
            </div>
          </details>

          <details class="deep-card searchable" data-search="tool verification llm judge hybrid verification rag answer grounding">
            <summary>Verification Strategies (Tool vs LLM vs Hybrid)</summary>
            <div class="deep-content">
              <ul>
                <li><strong>Tool-based verification</strong>: fast, cheap, deterministic; good for quote/span support checks</li>
                <li><strong>LLM judge</strong>: better for semantic matching; more expensive and less deterministic</li>
                <li><strong>Hybrid</strong>: tool first, escalate to LLM when uncertainty remains</li>
              </ul>
              <p><strong>Practical recommendation:</strong> start tool-first, add LLM judge only where tool checks are too rigid.</p>
            </div>
          </details>

          <details class="deep-card searchable" data-search="rag loop diagram retrieve augment generate verify retry abstain">
            <summary>RAG Loop (Glance-Friendly Diagram)</summary>
            <div class="deep-content">
              <div class="diagram mono">
User Question
  -> Encode Question
  -> Retrieve Top-K Chunks from Vector DB
  -> Augment Prompt with Retrieved Context
  -> Generate Answer (LLM)
  -> Verify Answer Against Retrieved Context
     -> PASS: return answer
     -> FAIL: rewrite query / adjust retrieval / retry (max N)
  -> If no PASS after N tries: abstain
              </div>
            </div>
          </details>
        </section>

        <section id="rag-code" class="panel">
          <div class="section-head">
            <p class="eyebrow">Section 5</p>
            <h2>RAG Code Alignment (Based on Your `null_hypo.py` Flow)</h2>
            <p>
              This section maps directly to the flow you described: retrieve -> augment -> generate ->
              verify -> retry, plus where retrieval and answer metrics should live.
            </p>
          </div>

          <div class="cards two-col">
            <article class="note-card searchable" data-search="null_hypo baseline loop retrieve augment generate verify retry bounded loop">
              <h3>Baseline (H0) Loop You Described</h3>
              <ul>
                <li>Document ingestion -> chunk -> embed -> store in vector DB</li>
                <li>User question -> embed query -> retrieve matching chunks</li>
                <li>Augment prompt with retrieved context</li>
                <li>LLM generates answer</li>
                <li>Verifier checks support/correctness against question + context</li>
                <li>If fail, retry loop with bounded max iterations</li>
              </ul>
            </article>

            <article class="note-card searchable" data-search="where to put metrics precision at k recall mrr hit rate relevance faithfulness">
              <h3>Where Metrics Go (Very Important)</h3>
              <ul>
                <li><strong>Retriever layer:</strong> Precision@K, Recall@K, MRR, Hit Rate</li>
                <li><strong>Generator/verifier layer:</strong> relevance, faithfulness (groundedness), precision of final answer</li>
                <li><strong>Pipeline layer:</strong> pass rate by iteration, abstain rate, average retries, latency/cost</li>
              </ul>
            </article>
          </div>

          <details class="deep-card searchable" open data-search="retrieval metrics definitions precision@k recall@k mrr hit rate">
            <summary>Retrieval Metrics (Definitions You Can Explain)</summary>
            <div class="deep-content">
              <ul>
                <li><strong>Precision@K</strong>: among top-K retrieved chunks, how many are relevant?</li>
                <li><strong>Recall@K</strong>: among all relevant chunks, how many did we retrieve in top-K?</li>
                <li><strong>MRR (Mean Reciprocal Rank)</strong>: how early is the first relevant chunk ranked?</li>
                <li><strong>Hit Rate@K</strong>: did at least one relevant chunk appear in top-K?</li>
              </ul>
              <p><strong>Use:</strong> diagnose retriever quality independent of LLM behavior.</p>
            </div>
          </details>

          <details class="deep-card searchable" data-search="answer-level metrics relevance faithfulness groundedness exactness">
            <summary>Answer-Level Metrics (LLM Output Quality)</summary>
            <div class="deep-content">
              <ul>
                <li><strong>Relevance</strong>: does the answer address the user question?</li>
                <li><strong>Faithfulness / groundedness</strong>: is the answer supported by retrieved context?</li>
                <li><strong>Abstention quality</strong>: does the system abstain when evidence is insufficient?</li>
                <li><strong>Final precision</strong>: proportion of final answers that are correct/acceptable</li>
              </ul>
            </div>
          </details>

          <details class="deep-card searchable" data-search="code alignment retriever verifier generator classes simple mental model">
            <summary>Simple Mental Model of Components (Retriever / Generator / Verifier)</summary>
            <div class="deep-content">
              <ul>
                <li><strong>Retriever</strong>: fetches candidate evidence from vector DB</li>
                <li><strong>Generator</strong>: composes answer from question + retrieved evidence</li>
                <li><strong>Verifier</strong>: checks if answer is supported and acceptable</li>
                <li><strong>Coordinator loop</strong>: decides PASS / RETRY / ABSTAIN</li>
              </ul>
              <p>
                This is enough to explain an "agentic" system clearly, even if the implementation is
                not a full agent framework.
              </p>
            </div>
          </details>

          <details class="deep-card searchable" data-search="bounded retry loop pseudo code max iterations pass fail abstain">
            <summary>Bounded Retry Loop (Pseudo-code)</summary>
            <div class="deep-content">
              <div class="code-block">
                <pre><code>for i in range(max_iters):
    chunks = retriever.retrieve(question_variant, top_k)
    answer = generator.generate(question, chunks)
    verdict = verifier.verify(question, answer, chunks)

    if verdict == PASS:
        return answer

    if i &lt; max_iters - 1:
        question_variant = rewrite(question, last_answer=answer)
    else:
        return ABSTAIN</code></pre>
              </div>
              <p><strong>Default recommendation:</strong> `max_iters = 2` or `3`.</p>
            </div>
          </details>

          <details class="deep-card searchable" data-search="simple chunk by words implementation easy explanation chunk_size overlap">
            <summary>Simpler Implementation for Learning: Chunk by Words</summary>
            <div class="deep-content">
              <p><strong>Yes, this is valid for learning and demos.</strong></p>
              <ul>
                <li>Split text into fixed-size word windows (e.g., 50 or 100 words)</li>
                <li>Optional overlap (e.g., 10 words) to reduce boundary loss</li>
                <li>Embed each chunk and store in vector DB</li>
                <li>Use the same retrieve -> generate -> verify loop</li>
              </ul>
              <p><strong>Tradeoff:</strong> easier to explain, but weaker semantic chunking than sentence/paragraph chunking.</p>
              <div class="code-block">
                <pre><code>def chunk_by_words(text, chunk_size=80, overlap=10):
    words = text.split()
    chunks = []
    step = max(1, chunk_size - overlap)
    for i in range(0, len(words), step):
        chunk = " ".join(words[i:i+chunk_size])
        if chunk:
            chunks.append(chunk)
    return chunks</code></pre>
              </div>
            </div>
          </details>

          <details class="deep-card searchable" data-search="how to explain your rag code to interviewer concise">
            <summary>How To Explain Your RAG Code in 45 Seconds</summary>
            <div class="deep-content">
              <p>
                I implemented a baseline RAG loop with bounded retries: retrieve relevant chunks from a
                vector DB, generate an answer using only retrieved context, verify whether the answer is
                supported, and retry retrieval with a rewritten query if verification fails. I track
                retrieval quality with Precision@K/Recall@K/MRR/Hit Rate and answer quality with
                relevance and faithfulness so I can debug whether failures come from retrieval or generation.
              </p>
            </div>
          </details>
        </section>

        <section id="transformer" class="panel">
          <div class="section-head">
            <p class="eyebrow">Section 6</p>
            <h2>Transformer Architecture Notes (Short + Detailed)</h2>
            <p>Few-line explanations and block diagrams you can recall quickly in interviews.</p>
          </div>

          <div class="cards two-col">
            <article class="note-card searchable" data-search="transformer architecture few lines answer">
              <h3>Few-Line Explanation</h3>
              <p>
                A transformer is a neural network architecture built around self-attention, which lets
                each token attend to other tokens in parallel to build context-aware representations.
                Each layer combines multi-head self-attention and a feed-forward network with residual
                connections and layer normalization, repeated many times.
              </p>
            </article>

            <article class="note-card searchable" data-search="decoder only transformer gpt style masked self attention next token prediction">
              <h3>GPT-Style (Decoder-Only) Summary</h3>
              <ul>
                <li>Masked self-attention (cannot see future tokens)</li>
                <li>Autoregressive next-token prediction</li>
                <li>Stack of transformer blocks + output projection to vocabulary logits</li>
                <li>This matches your GPT-style transformer project framing</li>
              </ul>
            </article>
          </div>

          <details class="deep-card searchable" open data-search="transformer block diagram embeddings positional encoding attention ffn add norm">
            <summary>Transformer Block Diagram (Text Form)</summary>
            <div class="deep-content">
              <div class="diagram mono">
Input Tokens
  -> Token Embeddings + Positional Encoding
  -> [Transformer Block] x N
      -> Multi-Head Self-Attention (Q, K, V)
      -> Add + LayerNorm
      -> Feed-Forward Network (MLP)
      -> Add + LayerNorm
  -> Linear Layer (vocab logits)
  -> Softmax (token probabilities)
              </div>
            </div>
          </details>

          <details class="deep-card searchable" data-search="self attention q k v formula scaled dot product sqrt dk">
            <summary>Self-Attention: What Q, K, V Mean</summary>
            <div class="deep-content">
              <ul>
                <li><strong>Query (Q)</strong>: what a token is asking for</li>
                <li><strong>Key (K)</strong>: what a token can be matched on</li>
                <li><strong>Value (V)</strong>: the content passed forward if attended to</li>
              </ul>
              <div class="code-block">
                <pre><code>Q = XWq, K = XWk, V = XWv
Attention(Q,K,V) = softmax(QK^T / sqrt(dk)) V</code></pre>
              </div>
              <p><strong>Why divide by sqrt(dk)?</strong> To keep attention scores numerically stable during training.</p>
            </div>
          </details>

          <details class="deep-card searchable" data-search="multi head attention why multiple heads different relationships">
            <summary>Why Multi-Head Attention?</summary>
            <div class="deep-content">
              <p>
                Multiple heads let the model learn different token relationships in parallel, such as
                local syntax, long-range references, and semantic associations.
              </p>
            </div>
          </details>

          <details class="deep-card searchable" data-search="positional encoding why needed order information transformer">
            <summary>Why Positional Encoding?</summary>
            <div class="deep-content">
              <p>
                Self-attention alone does not encode token order, so positional encodings/embeddings are
                added to inject sequence position information.
              </p>
            </div>
          </details>

          <details class="deep-card searchable" data-search="residual connections layer norm feedforward network why important transformer">
            <summary>Residuals + LayerNorm + FFN (Why They Matter)</summary>
            <div class="deep-content">
              <ul>
                <li><strong>Residual connections</strong> help gradients flow and preserve information</li>
                <li><strong>Layer normalization</strong> stabilizes training</li>
                <li><strong>Feed-forward network</strong> adds non-linear transformation capacity at each position</li>
              </ul>
            </div>
          </details>

          <details class="deep-card searchable" data-search="encoder only bert vs decoder only gpt comparison">
            <summary>Encoder-Only vs Decoder-Only (Interview Contrast)</summary>
            <div class="deep-content">
              <ul>
                <li><strong>Encoder-only (BERT-style):</strong> bidirectional attention, great for understanding/classification</li>
                <li><strong>Decoder-only (GPT-style):</strong> causal attention, great for generation/next-token prediction</li>
                <li><strong>Encoder-decoder:</strong> common in sequence-to-sequence tasks (translation, summarization)</li>
              </ul>
            </div>
          </details>

          <details class="deep-card searchable" data-search="how to explain transformer project interview from scratch pytorch">
            <summary>How To Describe Your Transformer Project</summary>
            <div class="deep-content">
              <p>
                I built a GPT-style decoder-only transformer to understand the architecture from first
                principles. I implemented tokenization/training flow, masked self-attention, positional
                embeddings, and stacked transformer blocks, then trained the model for next-token
                prediction. The project gave me direct intuition for attention mechanics, compute/memory
                tradeoffs, and practical training constraints.
              </p>
            </div>
          </details>
        </section>

        <section id="practice" class="panel">
          <div class="section-head">
            <p class="eyebrow">Section 7</p>
            <h2>Technical Practice Questions (Focused Scope)</h2>
            <p>Practice only the topics in this page: API design, system design, RAG, transformers.</p>
          </div>

          <div class="cards two-col">
            <details class="deep-card searchable" open data-search="api design interview questions contract idempotency retry errors versioning">
              <summary>API Design Practice Questions</summary>
              <div class="deep-content">
                <ul>
                  <li>What makes a good API contract?</li>
                  <li>How would you make a POST endpoint idempotent?</li>
                  <li>When should a client retry? Which status codes are retryable?</li>
                  <li>What should an error payload contain?</li>
                  <li>How do you version APIs and deprecate safely?</li>
                  <li>How do you design long-running API workflows?</li>
                </ul>
              </div>
            </details>

            <details class="deep-card searchable" data-search="system design practice questions fr nfr scalability availability consistency tradeoffs">
              <summary>System Design Practice Questions</summary>
              <div class="deep-content">
                <ul>
                  <li>Explain FR vs NFR with examples.</li>
                  <li>What clarifying questions do you ask before designing a system?</li>
                  <li>How do NFRs change architecture choices?</li>
                  <li>How do you estimate capacity if numbers are not given?</li>
                  <li>Discuss performance vs consistency tradeoffs in a read-heavy API.</li>
                </ul>
              </div>
            </details>

            <details class="deep-card searchable" data-search="rag interview questions embeddings vectorization retriever verifier metrics">
              <summary>RAG / Agentic Flow Practice Questions</summary>
              <div class="deep-content">
                <ul>
                  <li>Explain embeddings vs vectors vs vectorization.</li>
                  <li>Why is top-K retrieval not enough by itself?</li>
                  <li>How do you verify generated answers?</li>
                  <li>Why loop back to retrieval instead of only regenerating?</li>
                  <li>Where do Precision@K, Recall@K, MRR, Hit Rate fit?</li>
                  <li>How many retries should a RAG loop allow and why?</li>
                </ul>
              </div>
            </details>

            <details class="deep-card searchable" data-search="transformer interview questions self attention qkv multi head positional encoding">
              <summary>Transformer Practice Questions</summary>
              <div class="deep-content">
                <ul>
                  <li>Explain transformer architecture in a few lines.</li>
                  <li>What are Q, K, V in self-attention?</li>
                  <li>Why multi-head attention?</li>
                  <li>Why positional encoding?</li>
                  <li>Difference between BERT and GPT architectures?</li>
                  <li>How would you explain your transformer project to a non-ML engineer?</li>
                </ul>
              </div>
            </details>
          </div>
        </section>

        <section id="final-check" class="panel">
          <div class="section-head">
            <p class="eyebrow">Section 8</p>
            <h2>Final Cram Sheet (Last 15-20 Minutes)</h2>
            <p>Use this just before the interview or mock session.</p>
          </div>

          <div class="cards two-col">
            <article class="note-card searchable" data-search="final cram api design checklist">
              <h3>API Design Cram</h3>
              <ul>
                <li>Contract, validation, examples</li>
                <li>Idempotency for POST + retries</li>
                <li>Structured errors + request IDs</li>
                <li>Authn/Authz + rate limits</li>
                <li>202 for long-running workflows</li>
                <li>Versioning + deprecation plan</li>
                <li>Observability and testing</li>
              </ul>
            </article>

            <article class="note-card searchable" data-search="final cram system design checklist fr nfr">
              <h3>System Design Cram</h3>
              <ul>
                <li>Clarify FR first, then NFR</li>
                <li>Use PASS CURES checklist</li>
                <li>Estimate RPS/storage with clear assumptions</li>
                <li>Design for failure and retries</li>
                <li>Discuss tradeoffs explicitly</li>
              </ul>
            </article>

            <article class="note-card searchable" data-search="final cram rag checklist retriever verifier metrics">
              <h3>RAG Cram</h3>
              <ul>
                <li>Embedding = process, vector = result</li>
                <li>Retriever gets evidence, generator answers, verifier checks support</li>
                <li>Retry retrieval because query phrasing affects search results</li>
                <li>Bound loop to 2-3 tries</li>
                <li>Retriever metrics vs answer metrics</li>
              </ul>
            </article>

            <article class="note-card searchable" data-search="final cram transformer checklist qkv attention">
              <h3>Transformer Cram</h3>
              <ul>
                <li>Self-attention + QKV + scaled dot-product</li>
                <li>Multi-head attention learns different relationships</li>
                <li>Positional encoding adds order</li>
                <li>Residual + LayerNorm stabilize deep training</li>
                <li>Decoder-only = causal generation (GPT-style)</li>
              </ul>
            </article>
          </div>

          <div class="banner searchable" data-search="final reminder technical interview answer structure">
            <p>
              <strong>Final reminder:</strong> In technical interviews, explain assumptions,
              constraints, tradeoffs, and failure handling. That is usually what separates strong
              answers from generic ones.
            </p>
          </div>
        </section>
      </main>
    </div>

    <footer class="footer">
      <p>
        Local technical interview study page focused on API design, system design, RAG workflow/code,
        and transformer architecture.
      </p>
      <a href="#top">Back to top</a>
    </footer>

    <script src="script.js"></script>
  </body>
</html>
